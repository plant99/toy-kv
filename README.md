# toy-kv
Toy KV store: distributed and in-memory.

### How to run?

```bash
# clone the repository
 go build  -o ./tkv

# starting orchestrator server
./tkv -type orch  -action start -port 8080

# starting worker nodes
./tkv -type worker -action start -port 8081 -serverURL "http://localhost:8080"
./tkv -type worker -action start -port 8083 -serverURL "http://localhost:8080"
./tkv -type worker -action start -port 8082 -serverURL "http://localhost:8080"
```

One can also build the docker image with `docker build . -t tkv` and use it as a CLI. I.e, the command to start orchestrator server becomes

```bash
docker run --net="host" -it tkv:latest /tkv -type orch  -action start -port 8080
```
### API

To get a key:

```
GET http://localhost:8080/get?key=agfdg
```

To PUT a key:

```
GET http://localhost:8080/put?key=agfdg&value=lsdfg
```

To DELETE a key:

```
GET http://localhost:8080/delete?key=agfdg&
```

### Design Overview

- Services are of two types
    - **orchestrator**: Entrypoint for HTTP API and keeps track of _worker_ nodes described in the next section.
    - **worker**: Worker nodes act as storage units, they expose HTTP API for orchestrator to interact.
- Orchestrator keeps track of these data
    - `nodes` containing list of worker nodes connected.
    - `keyDirectory` containing list of keys and the nodes containing each key.
        - `REPLICATION_COUNT` is the number of copies to be made of each key and can be modified in `model.go`
- Worker keeps track of these data
    - `kvStore` to store key-value pairs
    - `workerId` to store its nodeId generated by orchestrator.

A typical workflow would look like the following

- When orchestration server starts, `kvDirectory` and `nodes` are initialized
- When a worker nodes starts up
    - it sends a request to orchestrator on `/register`
    - orchestrator generates an ID for it
- When number of workers > REPLICATION_COUNT
    - orchestrator responds to GET, PUT, DELETE API calls
- When a different node joins
    - Alongside registration, orchestrator relocates some KV pairs from different nodes to this new node.
- When a node leaves, it sends a request to `/deregister` in orchestrator
    - Orchestrator distributes this nodes' KVs to other nodes.



### TODOs and improvements

 - Read/write locks should be implemented for both 'key' and 'node' to provide better consistency.
 - Gossip protocols / leader election should be used instead of a central orchestrator.
 - Unit and integration tests should be implemented.
 - Currently services communicate via JSON
    - this can be replaced by protobuf since data is structured.
 - RPC can replace HTTP to simplify internal communication
 - CLI should include a client to interact with the cluster
 - During shuffles (when a node joins or leaves), a batch PUT option would help out
